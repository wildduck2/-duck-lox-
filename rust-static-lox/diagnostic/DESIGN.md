> THIS FILE IS GENERATED BY AI, DO NOT EDIT

# Diagnostic System Design

## Overview

This diagnostic system is modeled after Rust's compiler diagnostics (rustc), providing structured, colorized error messages with source code context, labeled spans, and helpful suggestions.

## Comparison with Rust Compiler

### âœ… Matches Rust's Design

1. **Byte-based Spans**: Uses byte offsets (not character offsets) for accurate multi-byte character handling
2. **SourceMap Pattern**: Central registry of source files with efficient line/column lookups
3. **Label System**: Primary (red) and secondary (blue) labels for highlighting multiple regions
4. **Severity-based Colors**: Different colors for errors, warnings, notes, and help messages
5. **Context Padding**: Configurable number of lines shown above/below errors
6. **Rust-style Formatting**: Header, location arrow (`-->`), pipe separators (`|`), and `= help:`/`= note:` format

### Differences

- **Icons**: Uses Unicode icons (âœ—, âš , â„¹, â—) which Rust doesn't use in terminal output
- **Code Coloring**: Code brackets are colored by severity (red/yellow/cyan/blue) - Rust keeps them neutral grey

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DiagnosticEngine                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              SourceMap                                â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚  â”‚  â”‚  BTreeMap<String, SourceFile>                 â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  - "main.rs" â†’ SourceFile                     â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  - "lib.rs" â†’ SourceFile                      â”‚   â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Vec<Diagnostic>                                     â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚  Diagnostic                                    â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - code: DiagnosticCode                        â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - message: String                             â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - labels: Vec<Label>                          â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - help/note: Option<String>                   â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Components Explained

### 1. SourceMap & SourceFile

**Purpose**: Efficiently map file paths to source content and provide byte offset â†” line/column conversions.

**Why Byte Offsets?**

```
Source: "fn main() {\n    let x = 5;\n}"
         ^           ^              ^
Byte:   0           12             26

Characters â‰  Bytes:
- ASCII: 1 char = 1 byte âœ“
- UTF-8: 1 char = 1-4 bytes (e.g., "ğŸ¦†" = 4 bytes)
- Tabs: 1 char = 1 byte (but displayed as 4-8 spaces)
```

**Line Offset Table**:
```
Source: "fn main() {\n    let x = 5;\n    println!(\"hi\");\n}"
         |           |              |              |
Byte:    0          12             26             45

Line Offsets: [0, 12, 26, 45]
Line 1: bytes 0..12
Line 2: bytes 12..26
Line 3: bytes 26..45
```

**How `line_col()` Works**:
```
1. Binary search in line_offsets to find which line contains byte_offset
2. Calculate column = byte_offset - line_start + 1
3. Return (line_number, column) both 1-indexed
```

**Visual Example**:
```
SourceFile {
  path: "main.rs",
  src: "fn main() {\n    let x = 5;\n}",
  line_offsets: [0, 12, 26]
}

byte_offset = 20
  â†’ line_col(20) = (2, 8)  // Line 2, column 8 (the '5')
```

### 2. Span

**Purpose**: Represent a byte range in source code (start..end).

**Structure**:
```rust
Span {
  start: usize,  // Inclusive byte offset
  end: usize,   // Exclusive byte offset
}
```

**Why Start/End Pattern?**
- Matches Rust's `Range<usize>` (start..end)
- Easy to slice: `&source[span.start..span.end]`
- Length calculation: `span.end - span.start`

**Example**:
```
Source: "let x = counter;"
         ^   ^ ^        ^
         |   | |        |
         |   | |        end (16)
         |   | start (8)
         |   end (9)
         start (0)
```

**Converting Line/Col to Span**:
```
Given: line 3, col 5, length 7
SourceFile knows line 3 starts at byte 45

Calculation:
  start = line_start + (col - 1)  // col is 1-indexed
  start = 45 + (5 - 1) = 49
  end = start + length = 49 + 7 = 56

Span { start: 49, end: 56 }
```

### 3. Diagnostic

**Purpose**: Container for all error/warning information.

**Structure**:
```
Diagnostic {
  code: DiagnosticCode,        // E0425, W0001, etc.
  message: String,             // Human-readable message
  file_path: String,           // "src/main.rs"
  labels: Vec<Label>,          // Highlighted regions
  help: Option<String>,        // Suggestions
  note: Option<String>,        // Additional context
  severity: Severity,          // Error/Warning/Note/Help
  context_padding: usize,      // Lines above/below (default: 2)
}
```

**Builder Pattern**:
```rust
Diagnostic::new(code, message, file_path)
  .with_label(span, Some("message"), LabelStyle::Primary)
  .with_help("suggestion".to_string())
  .with_note("context".to_string())
  .with_context_padding(3)
```

### 4. Label

**Purpose**: Highlight specific regions in source code.

**Types**:
- **Primary** (red): The main error location
- **Secondary** (blue): Related locations (e.g., where a type was expected)

**Visual Example**:
```
fn process(value: i32) -> String {
    value * 2
}

Primary label:   ^^^^^^ expected String, found i32
Secondary label:  ^ expected String because of return type
```

**Marker Generation**:
```
Length 1: "^"
Length 2: "^^"
Length 3+: "^~~~"  (Rust-style wavy underline)
```

### 5. Formatting Pipeline

**Step-by-Step Process**:

```
1. HEADER
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ âœ— error[E0425]: cannot find value   â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   - Icon based on severity
   - "error" in red/yellow/cyan/blue
   - "[CODE]" colored by severity
   - Message in white

2. LOCATION
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚   --> src/main.rs:5:27              â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   - Blue arrow and path
   - Line:column from primary span

3. CONTEXT LOADING
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Find all labels                     â”‚
   â”‚ Calculate min_line..max_line        â”‚
   â”‚ Add padding (default Â±2 lines)      â”‚
   â”‚ Load lines from SourceFile         â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

4. SOURCE RENDERING
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ 3 | fn main() {                     â”‚
   â”‚   |                                â”‚
   â”‚ 4 |     let x = 5;                 â”‚
   â”‚   |                                â”‚
   â”‚ 5 |     println!("Count: {}", counter);â”‚
   â”‚   |                          ^^^^^^^ not found in this scopeâ”‚
   â”‚   |                                â”‚
   â”‚ 6 | }                              â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   - Line numbers in blue
   - Pipes (|) in blue
   - Source code in white
   - Labels with colored markers

5. HELP/NOTE
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚  = help: a local variable with a   â”‚
   â”‚    similar name exists: `count`    â”‚
   â”‚  = note: expected type `String`     â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Why This Design Works

### 1. Byte Offsets Over Character Offsets

**Problem**: UTF-8 characters can be multiple bytes. Character offsets break with:
- Emoji: `"ğŸ¦†"` = 4 bytes
- Accented letters: `"Ã©"` = 2 bytes
- Multi-byte characters in identifiers

**Solution**: Always work with byte offsets, convert to line/col only for display.

**Example**:
```
Source: "let ğŸ¦† = 5;"
         ^   ^
Byte:    0   4  (correct)
Char:    0   1  (misleading - emoji is 1 char, 4 bytes)
```

### 2. SourceMap Centralization

**Problem**: Without SourceMap:
- Each diagnostic needs its own source file copy
- No efficient way to look up line/col from byte offset
- Duplicated line offset calculations

**Solution**: Single SourceMap shared across all diagnostics:
- Register files once: `source_map.add_file(path, src)`
- All diagnostics reference the same file data
- Efficient binary search for line lookups

**Memory Efficiency**:
```
Without SourceMap:
  10 diagnostics Ã— 10KB source = 100KB duplicated

With SourceMap:
  1 source file = 10KB
  10 diagnostics = 0KB (just references)
```

### 3. Span-Based Labels

**Problem**: Line/column pairs are fragile:
- Multi-line errors need multiple line/col pairs
- Hard to extract actual source text
- No easy way to calculate length

**Solution**: Byte spans:
- Single span covers multi-line regions
- Easy to slice: `&source[span.start..span.end]`
- Length calculation: `span.len()`

### 4. Context Padding

**Problem**: Showing only the error line lacks context:
```
5 |     println!("Count: {}", counter);
```

**Solution**: Show surrounding lines:
```
3 | fn main() {
4 |     let count = 5;
5 |     println!("Count: {}", counter);
6 | }
```

**Why Configurable?**
- Simple errors: 2 lines is enough
- Complex errors (borrow checker): 1 line to avoid clutter
- Wide context needed: 5+ lines for deep nesting

### 5. Label Grouping by Line

**Problem**: Multiple labels on same line need special handling:
```
5 |     println!("Count: {}", counter);
   |                    ^^^^  ^^^^^^^
   |                    |     |
   |                    |     Primary label
   |                    Secondary label
```

**Solution**: Group labels by line number before rendering:
```rust
let mut lines_with_labels: HashMap<usize, Vec<&Label>> = ...;
for label in &self.labels {
    let (line, _) = file.line_col(label.span.start);
    lines_with_labels.entry(line).or_insert_with(Vec::new).push(label);
}
```

Then render each line once, but all its labels together.

## Complete Example

**Source Code** (`main.rs`):
```rust
fn main() {
    let count = 5;
    let result = calculate(count);
    
    println!("Count: {}", counter);
    println!("Result: {}", result);
}
```

**Creating the Diagnostic**:
```rust
let mut source_map = SourceMap::new();
let src = std::fs::read_to_string("main.rs")?;
source_map.add_file("main.rs", &src);

let file = source_map.get("main.rs").unwrap();
let span = Span::from_line_col(5, 28, 7, file); // "counter" span

let diagnostic = Diagnostic::new(
    DiagnosticCode::Error(DiagnosticError::UndefinedVariable),
    "cannot find value `counter` in this scope".to_string(),
    "main.rs".to_string(),
)
.with_label(span, Some("not found in this scope".to_string()), LabelStyle::Primary)
.with_help("a local variable with a similar name exists: `count`".to_string());
```

**Output**:
```
âœ— error[E0425]: cannot find value `counter` in this scope
  --> main.rs:5:28
   |
3  | fn main() {
   |
4  |     let count = 5;
   |
5  |     println!("Count: {}", counter);
   |                          ^^^^^^^ not found in this scope
   |
6  | }
   |
  = help: a local variable with a similar name exists: `count`
```

## Performance Considerations

### 1. Line Offset Table Construction

**Time**: O(n) where n = source length
- Single pass through source to find newlines
- Stored once in SourceFile

**Space**: O(m) where m = number of lines
- One usize per line (typically 8 bytes)

### 2. Binary Search for line_col()

**Time**: O(log m) where m = number of lines
- Binary search in sorted line_offsets array
- Much faster than linear search for large files

### 3. Context Loading

**Time**: O(p) where p = number of context lines
- Only loads lines that will be displayed
- No need to scan entire file

**Optimization**: Pre-compute line_offsets once, reuse for all diagnostics.

## Design Principles

1. **Separation of Concerns**
   - SourceMap: File management
   - Diagnostic: Message structure
   - Formatting: Display logic

2. **Builder Pattern**
   - Fluent API: `.with_label().with_help()`
   - Immutable construction (each method returns new Diagnostic)

3. **Error Handling**
   - `Result` types for I/O operations
   - Graceful degradation (no source map = no context)

4. **Rust-like API**
   - Familiar to Rust developers
   - Consistent with ecosystem conventions

## Future Enhancements

1. **Suggestions**: Automatic code fixes (like Rust's `--fix`)
2. **Multi-file Errors**: Show spans across multiple files
3. **Rich Text**: Support for markdown in messages
4. **JSON Output**: Machine-readable diagnostic format
5. **Custom Renderers**: HTML, terminal, IDE integration

