DIAGNOSTIC CRATE OVERVIEW

The diagnostic crate powers richly formatted, colorized diagnostics for the Lox toolchain. It focuses on producing readable compiler-style error messages that include spans, annotated source lines, and optional help or note text.

KEY IDEAS
1. DiagnosticEngine owns the input source, gathers diagnostics, and prints them in order.
2. Diagnostic holds the message, file path, labels, context lines, and optional help or note text.
3. DiagnosticCode wraps typed error and warning codes so every message carries a structured identifier and severity.
4. Labels describe primary and secondary spans, letting you highlight multiple regions in a single report.

DEFINING A DIAGNOSTIC
Start with Diagnostic::new, passing a DiagnosticCode, the human-readable message, and the file path. Chain builder helpers to attach context:
  • with_context_line(line_number, "source line") records the snippet to display.
  • with_label(Span { line, start, end }, Some("message"), LabelStyle::Primary) adds an annotated region.
  • with_help("suggestion") or with_note("extra detail") insert follow-up guidance.

The Span type uses 1-based line numbers and character offsets. Primary labels render as red carets (^^^^), secondary labels as cyan dashes (----).

INTEGRATING WITH THE ENGINE
Create a DiagnosticEngine, call insert_source with the original source text, push diagnostics with add, then call print_diagnostics when you are ready to report all accumulated issues.

TYPED CODES AND SEVERITIES
DiagnosticCode::Error and DiagnosticCode::Warning point to enums in diagnostic::types. Each variant exposes a stable Rust-style code string (for example, E0425 for undefined variables) and a Severity so you can react programmatically.

EXAMPLE
  use diagnostic::{
    code::DiagnosticCode,
    diagnostic::{Diagnostic, LabelStyle, Span},
    types::error::DiagnosticError,
    DiagnosticEngine,
  };

  let mut engine = DiagnosticEngine::new();
  engine.insert_source(r#"println!("Count: {}", counter);"#);

  let diagnostic = Diagnostic::new(
      DiagnosticCode::Error(DiagnosticError::UndefinedVariable),
      "cannot find value `counter` in this scope",
      "src/main.rs",
    )
    .with_context_line(5, r#"    println!("Count: {}", counter);"#)
    .with_label(
      Span { line: 5, start: 27, end: 34 },
      Some("not found in this scope"),
      LabelStyle::Primary,
    )
    .with_help("a local variable with a similar name exists: `count`");

  engine.add(diagnostic);
  engine.print_diagnostics();

Typical terminal output (colors omitted here) resembles:
error[E0425]: cannot find value `counter` in this scope
  --> src/main.rs:5:27
        |
5       |     println!("Count: {}", counter);
        |                           ^^^^^^^ not found in this scope
   = help: a local variable with a similar name exists: `count`

TESTING
Run cargo test -p diagnostic to see end-to-end examples that cover simple through super-complex reports. The tests print sample diagnostics so you can review formatting as it evolves.
