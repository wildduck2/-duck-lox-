/* ---------------------------------------------------------------------------------------------- */
/*  NOTE THIS FILE IS GENERATED BY AI DO NOT EDIT IT IS FOR DEBUGGING PURPOSES ONLY               */
/* ---------------------------------------------------------------------------------------------- */

use crate::ast::{print::print_tree::*, *};

impl Item {
  pub fn print_tree(&self, prefix: &str, is_last: bool) {
    let connector = if is_last { "└─>" } else { "├─>" };

    match self {
      Item::Struct(struct_decl) => {
        println!("{}{} Struct '{}'", prefix, connector, struct_decl.name);
        let base = format!("{}{}  ", prefix, if is_last { " " } else { "│" });

        // visibility
        println!(
          "{}├─> Visibility: {}",
          base,
          fmt_visibility(&struct_decl.visibility)
        );

        // generics
        if let Some(g) = &struct_decl.generics {
          println!("{}├─> Generics:", base);
          let gen_base = format!("{base}│  ");
          for (i, gp) in g.params.iter().enumerate() {
            let last = i + 1 == g.params.len();
            print_generic_param(&gen_base, last, gp);
          }
        } else {
          println!("{}├─> Generics: <none>", base);
        }

        // kind
        match &struct_decl.kind {
          StructKind::Unit => {
            println!("{}├─> Kind: Unit", base);
          }
          StructKind::Tuple(tfields) => {
            println!("{}├─> Kind: Tuple", base);
            let kbase = format!("{base}│  ");
            if tfields.is_empty() {
              println!("{kbase}└─> <no fields>");
            } else {
              for (i, f) in tfields.iter().enumerate() {
                let last = i + 1 == tfields.len();
                println!("{kbase}{} TupleField:", if last { "└─>" } else { "├─>" });
                let fb = format!("{kbase}{}  ", if last { " " } else { "│" });
                print_attribute_list(&fb, false, &f.attributes);
                println!("{fb}├─> Visibility: {}", fmt_visibility(&f.visibility));
                println!("{fb}└─> Type: {}", format_type(&f.ty));
              }
            }
          }
          StructKind::Named { fields } => {
            println!("{}├─> Kind: Named", base);
            let kbase = format!("{base}│  ");
            if fields.is_empty() {
              println!("{kbase}└─> <no fields>");
            } else {
              println!("{kbase}├─> Fields:");
              let fbase = format!("{kbase}│  ");
              for (i, f) in fields.iter().enumerate() {
                let last = i + 1 == fields.len();
                println!(
                  "{fbase}{} Field '{}':",
                  if last { "└─>" } else { "├─>" },
                  f.name
                );
                let fb = format!("{fbase}{}  ", if last { " " } else { "│" });
                print_attribute_list(&fb, false, &f.attributes);
                println!("{fb}├─> Visibility: {}", fmt_visibility(&f.visibility));
                println!("{fb}└─> Type: {}", format_type(&f.ty));
              }
            }
          }
        }

        // where clause
        print_where_clause(&base, true, &struct_decl.where_clause);
      }
      _ => {
        println!("{}{} [Other Item]", prefix, connector);
      }
    }
  }
}

fn fmt_visibility(v: &Visibility) -> String {
  match v {
    Visibility::Lic => "lic".into(),
    Visibility::LicCrate => "lic(crate)".into(),
    Visibility::LicSuper => "lic(super)".into(),
    Visibility::LicSelf => "lic(self)".into(),
    Visibility::LicIn(path) => format!("lic(in {})", format_path(path)),
    Visibility::Private => "private".into(),
  }
}

fn fmt_trait_bound_modifier(m: &TraitBoundModifier) -> &'static str {
  match m {
    TraitBoundModifier::None => "",
    TraitBoundModifier::Maybe => "?",
    TraitBoundModifier::MaybeConst => "?const ",
    TraitBoundModifier::Const => "const ",
  }
}

fn print_type_bounds(prefix: &str, is_last: bool, bounds_opt: &Option<Vec<TypeBound>>) {
  let connector = if is_last { "└─>" } else { "├─>" };
  match bounds_opt {
    None => println!("{prefix}{connector} Bounds: <none>"),
    Some(v) if v.is_empty() => {
      println!("{prefix}{connector} Bounds: <none>");
    }
    Some(v) => {
      println!("{prefix}{connector} Bounds:");
      let inner_prefix = format!("{prefix}{}  ", if is_last { " " } else { "│" });
      for (i, b) in v.iter().enumerate() {
        let last = i + 1 == v.len();
        let modstr = fmt_trait_bound_modifier(&b.modifier);
        let path = format_path(&b.path);
        if let Some(ls) = &b.for_lifetimes {
          let lifetimes = ls.join(", ");
          println!(
            "{}{} {}for<{}>{}",
            inner_prefix,
            if last { "└─>" } else { "├─>" },
            modstr,
            lifetimes,
            path
          );
        } else {
          println!(
            "{}{} {}{}",
            inner_prefix,
            if last { "└─>" } else { "├─>" },
            modstr,
            path
          );
        }
      }
    }
  }
}

fn print_attribute_list(prefix: &str, title_is_last: bool, attrs: &Vec<Attribute>) {
  let connector = if title_is_last { "└─>" } else { "├─>" };
  if attrs.is_empty() {
    println!("{prefix}{connector} Attributes: <none>");
    return;
  }
  println!("{prefix}{connector} Attributes:");
  let inner = format!("{prefix}{}  ", if title_is_last { " " } else { "│" });
  for (i, a) in attrs.iter().enumerate() {
    let last = i + 1 == attrs.len();
    println!(
      "{}{} {}",
      inner,
      if last { "└─>" } else { "├─>" },
      format_attr(a)
    );
  }
}

fn print_generic_param(prefix: &str, is_last: bool, gp: &GenericParam) {
  let connector = if is_last { "└─>" } else { "├─>" };
  match gp {
    GenericParam::Type {
      attributes,
      name,
      bounds,
      default,
    } => {
      println!("{prefix}{connector} Type param: {name}");
      let inner = format!("{prefix}{}  ", if is_last { " " } else { "│" });
      // attributes
      print_attribute_list(&inner, false, attributes);
      // bounds (not last, because Default comes after it)
      print_type_bounds(&inner, false, bounds);
      // default
      if let Some(ty) = default {
        println!("{inner}└─> Default: {}", format_type(ty));
      } else {
        println!("{inner}└─> Default: <none>");
      }
    }

    GenericParam::Lifetime {
      attributes,
      name,
      bounds,
    } => {
      println!("{prefix}{connector} Lifetime param: '{name}");
      let inner = format!("{prefix}{}  ", if is_last { " " } else { "│" });
      // attributes (not last, because Outlives comes after)
      print_attribute_list(&inner, false, attributes);

      match bounds {
        None => println!("{inner}└─> Outlives: <none>"),
        Some(v) if v.is_empty() => println!("{inner}└─> Outlives: <none>"),
        Some(v) => {
          let joined = v
            .iter()
            .map(|b| format_path(&b.path))
            .collect::<Vec<_>>()
            .join(" + ");
          println!("{inner}└─> Outlives: {}", joined);
        }
      }
    }

    GenericParam::Const {
      attributes,
      name,
      ty,
      default,
    } => {
      println!("{prefix}{connector} Const param: {name}");
      let inner = format!("{prefix}{}  ", if is_last { " " } else { "│" });
      print_attribute_list(&inner, false, attributes);
      println!("{inner}├─> Type: {}", format_type(ty));
      if let Some(r#type) = default {
        println!("{inner}└─> Default: {}", format_type(r#type));
      } else {
        println!("{inner}└─> Default: <none>");
      }
    }
  }
}

fn print_where_clause(prefix: &str, is_last: bool, wc: &Option<WhereClause>) {
  let connector = if is_last { "└─>" } else { "├─>" };
  match wc {
    None => println!("{prefix}{connector} WhereClause: <none>"),
    Some(w) => {
      if w.predicates.is_empty() {
        println!("{prefix}{connector} WhereClause: <empty>");
        return;
      }
      println!("{prefix}{connector} WhereClause:");
      let inner = format!("{prefix}{}  ", if is_last { " " } else { "│" });
      for (i, p) in w.predicates.iter().enumerate() {
        let last = i + 1 == w.predicates.len();
        match p {
          WherePredicate::Type {
            for_lifetimes,
            ty,
            bounds,
          } => {
            println!(
              "{inner}{} Type: {}",
              if last { "└─>" } else { "├─>" },
              format_type(ty)
            );
            let inner2 = format!("{inner}{}  ", if last { " " } else { "│" });
            if let Some(ls) = for_lifetimes {
              println!("{inner2}├─> for<{}>", ls.join(", "));
            } else {
              println!("{inner2}├─> for: <none>");
            }
            print_type_bounds(&inner2, true, bounds);
          }
          WherePredicate::Lifetime { lifetime, bounds } => {
            println!(
              "{inner}{} Lifetime: '{}",
              if last { "└─>" } else { "├─>" },
              lifetime
            );
            let inner2 = format!("{inner}{}  ", if last { " " } else { "│" });
            if bounds.is_empty() {
              println!("{inner2}└─> Outlives: <none>");
            } else {
              println!("{inner2}└─> Outlives: {}", bounds.join(" + "));
            }
          }
          WherePredicate::Equality { ty, equals } => {
            println!("{inner}{} Equality:", if last { "└─>" } else { "├─>" });
            let inner2 = format!("{inner}{}  ", if last { " " } else { "│" });
            println!("{inner2}├─> Left: {}", format_type(ty));
            println!("{inner2}└─> Right: {}", format_type(equals));
          }
        }
      }
    }
  }
}
