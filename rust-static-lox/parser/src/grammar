/*
 * Complete Rust Grammar - Recursive Descent Parsing Style (ASCII only)
 */

program           -> shebang? innerAttr* item* EOF ;

shebang           -> "#!" ~[\n]* ;

/* ------------------------------------------------------------------------- */
/* Items                                                                     */
/* ------------------------------------------------------------------------- */

item              -> outerAttr* visItem ;

visItem           -> visibility? itemKind
                   | macroItem ;

itemKind          -> functionItem
                   | structItem
                   | enumItem
                   | traitItem
                   | implItem
                   | constItem
                   | staticItem
                   | typeAliasItem
                   | moduleItem
                   | useItem
                   | externCrateItem
                   | foreignModItem
                   | unionItem
                   | externTypeItem ;

/* ------------------------------------------------------------------------- */
/* Macros                                                                    */
/* ------------------------------------------------------------------------- */

macroItem         -> macroInvocationSemi
                   | macroRulesItem
                   | macro2Item ;

outerAttr         -> "#" "[" attrInput "]" ;
innerAttr         -> "#" "!" "[" attrInput "]" ;

attrInput         -> simplePath attrInputTail? ;

attrInputTail     -> delimTokenTree
                   | "=" expression ;

delimTokenTree    -> "(" tokenStream ")"
                   | "[" tokenStream "]"
                   | "{" tokenStream "}" ;

metaItem          -> simplePath ("(" metaSeq ")" | "=" literalExpr)? ;
metaSeq           -> metaItemInner ("," metaItemInner)* ","? ;
metaItemInner     -> metaItem | literalExpr ;

/* ------------------------------------------------------------------------- */
/* Functions                                                                 */
/* ------------------------------------------------------------------------- */

/* Split signature from bodies to model semantics precisely */
functionSig       -> functionQualifiers "fn" IDENTIFIER
                     genericParams? "(" functionParams? ")" functionReturnType?
                     whereClause? ;

functionItem      -> functionSig blockExpr ;                 /* free functions need a body */

foreignFunctionItem
                  -> functionSig ";" ;                       /* foreign items end with ';' */

associatedFunctionItem
                  -> functionSig (blockExpr | ";") ;         /* traits may have default bodies or ';' */

/* Qualifiers */
functionQualifiers -> "const"? "async"? "unsafe"? ("extern" abi?)? ;

abi               -> STRING | RAW_STRING ;

functionParams    -> selfParam ("," functionParam)* ","?
                   | functionParam ("," functionParam)* ","? ;

selfParam         -> outerAttr* (shorthandSelf | typedSelf) ;
shorthandSelf     -> ("&" LIFETIME?)? "mut"? "self" ;
typedSelf         -> "mut"? "self" ":" type ;

functionParam     -> outerAttr* (functionParamPattern | "...") ;
functionParamPattern -> patternNoTopAlt (":" (type | "..."))? ;

functionReturnType -> "->" type ;

/* ------------------------------------------------------------------------- */
/* Structs                                                                   */
/* ------------------------------------------------------------------------- */

/*
   Struct where placement rules:
   - record:    where BEFORE '{', no trailing ';'
   - tuple:     where AFTER ')', then ';' is required
   - unit:      where BEFORE ';', ';' is required
*/
structItem        -> "struct" IDENTIFIER genericParams?
                     ( whereClause? recordStructFields
                     | tupleStructFields whereClause? ";"
                     | whereClause? ";"
                     ) ;

recordStructFields -> "{" structFields? "}" ;
structFields      -> structField ("," structField)* ","? ;
structField       -> outerAttr* visibility? IDENTIFIER ":" type ;

tupleStructFields -> "(" tupleFields? ")" ;
tupleFields       -> tupleField ("," tupleField)* ","? ;
tupleField        -> outerAttr* visibility? type ;

/* ------------------------------------------------------------------------- */
/* Enums                                                                     */
/* ------------------------------------------------------------------------- */

enumItem          -> "enum" IDENTIFIER genericParams?
                     whereClause? "{" enumVariants? "}" ;

enumVariants      -> enumVariant ("," enumVariant)* ","? ;

enumVariant       -> outerAttr* visibility? IDENTIFIER
                     (enumVariantFields | discriminant)? ;

enumVariantFields -> recordStructFields | tupleStructFields ;
discriminant      -> "=" expression ;

/* ------------------------------------------------------------------------- */
/* Union                                                                     */
/* ------------------------------------------------------------------------- */

unionItem         -> "union" IDENTIFIER genericParams?
                     whereClause? recordStructFields ;

/* ------------------------------------------------------------------------- */
/* Consts, Statics, Type Aliases                                              */
/* ------------------------------------------------------------------------- */

/* Free-standing const must have initializer */
constItem         -> "const" (IDENTIFIER | "_") ":" type "=" expression ";" ;

/* Free-standing static may omit initializer */
staticItem        -> "static" "mut"? IDENTIFIER ":" type
                     ("=" expression)? ";" ;

/* Free-standing type alias must have '=' type */
typeAliasItem     -> "type" IDENTIFIER genericParams?
                     (":" typeParamBounds)?
                     whereClause? "=" type ";" ;

/* ------------------------------------------------------------------------- */
/* Traits and Impl                                                            */
/* ------------------------------------------------------------------------- */

traitItem         -> "unsafe"? "auto"? "trait" IDENTIFIER
                     genericParams? (":" typeParamBounds)?
                     whereClause? "{" innerAttr* associatedItem* "}" ;

implItem          -> "unsafe"? "impl" genericParams?
                     "const"? "!"? traitPath "for" type
                     whereClause? "{" innerAttr* associatedItem* "}"
                   | "unsafe"? "impl" genericParams? type
                     whereClause? "{" innerAttr* inherentImplItem* "}" ;

traitPath         -> typePath ;

associatedItem    -> outerAttr* (macroInvocationSemi | associatedItemKind) ;

associatedItemKind -> associatedTypeItem
                    | associatedConstItem
                    | associatedFunctionItem ;

/* Associated type: generics (GATs) allowed, optional bounds, optional where, optional default */
associatedTypeItem -> "type" IDENTIFIER genericParams? (":" typeParamBounds)?
                      whereClause? ("=" type)? ";" ;

/* Associated const: in traits value is optional, in impls it must be provided (semantic rule) */
associatedConstItem -> "const" IDENTIFIER ":" type ("=" expression)? ";" ;

inherentImplItem  -> outerAttr* (visibility? (functionItem | constItem) | macroInvocationSemi) ;

/* ------------------------------------------------------------------------- */
/* Externs, Modules, Use                                                      */
/* ------------------------------------------------------------------------- */

externCrateItem   -> "extern" "crate" crateRef asClause? ";" ;
crateRef          -> IDENTIFIER | "self" ;
asClause          -> "as" (IDENTIFIER | "_") ;

useItem           -> "use" useTree ";" ;
useTree           -> (simplePath? "::")? ("*" | useTreeList)
                   | simplePath ("as" (IDENTIFIER | "_"))? ;
useTreeList       -> "{" (useTree ("," useTree)* ","?)? "}" ;

moduleItem        -> "mod" IDENTIFIER (";" | "{" innerAttr* item* "}") ;

/* Foreign module: only foreignFunctionItem and foreign statics inside */
foreignModItem    -> "unsafe"? "extern" abi? "{" innerAttr* externalItem* "}" ;
externalItem      -> outerAttr* (macroInvocationSemi | (visibility? externalItemKind)) ;
externalItemKind  -> "static" "mut"? IDENTIFIER ":" type ";"
                   | foreignFunctionItem ;

/* extern type is a separate free item (no generics) */
externTypeItem    -> "extern" "type" IDENTIFIER ";" ;

/* ------------------------------------------------------------------------- */
/* Macros (defs)                                                              */
/* ------------------------------------------------------------------------- */

macroRulesItem    -> "macro_rules" "!" IDENTIFIER macroRulesDef ;
macroRulesDef     -> "(" macroRules ")" ";"
                   | "{" macroRules "}"
                   | "[" macroRules "]" ;

macroRules        -> macroRule (";" macroRule)* ";"? ;
macroRule         -> macroMatcher "=>" macroTranscriber ;

macroMatcher      -> "(" macroMatch* ")"
                   | "[" macroMatch* "]"
                   | "{" macroMatch* "}" ;

macroMatch        -> tokenExceptDelims
                   | macroMatcher
                   | "$" (IDENTIFIER ":" macroFragSpec | "(" macroMatch+ ")" macroRepSep? macroRepOp) ;

macroFragSpec     -> "block" | "expr" | "ident" | "item" | "lifetime" | "literal"
                   | "meta" | "pat" | "pat_param" | "path" | "stmt" | "tt" | "ty" | "vis" ;

macroRepSep       -> tokenExceptDelims | macroRepOp ;
macroRepOp        -> "*" | "+" | "?" ;

macroTranscriber  -> delimTokenTree ;

macro2Item        -> "macro" IDENTIFIER "(" macroParams? ")" delimTokenTree ;
macroParams       -> IDENTIFIER ("," IDENTIFIER)* ","? ;

/* ------------------------------------------------------------------------- */
/* Generics                                                                   */
/* ------------------------------------------------------------------------- */

genericParams     -> "<" (genericParam ("," genericParam)* ","?)? ">" ;
genericParam      -> outerAttr* (lifetimeParam | typeParam | constParam) ;

lifetimeParam     -> LIFETIME (":" lifetimeBounds)? ;

/* type param: optional bounds, optional default */
typeParam         -> IDENTIFIER (":" typeParamBounds)? ("=" type)? ;

/* const param: allow const-evaluable defaults */
constParam        -> "const" IDENTIFIER ":" type ("=" block | "=" IDENTIFIER | "=" literalExpr)? ;

/* where clause */
whereClause       -> "where" (whereClauseItem ("," whereClauseItem)* ","?)? ;
whereClauseItem   -> lifetimeWhereClauseItem
                   | typeBoundWhereClauseItem ;

lifetimeWhereClauseItem -> LIFETIME ":" lifetimeBounds ;
typeBoundWhereClauseItem -> forLifetimes? type ":" typeParamBounds? ;

/* bounds */
lifetimeBounds    -> (LIFETIME ("+" LIFETIME)*)? "+"? ;
typeParamBounds   -> typeParamBound ("+" typeParamBound)* "+"? ;
typeParamBound    -> LIFETIME
                   | traitBound ;

/* trait bounds */
traitBound        -> "?"? "const"? forLifetimes? typePath ;

/* HRTB: only lifetimes may appear inside for<...> */
forLifetimes      -> "for" "<" LIFETIME ("," LIFETIME)* ","? ">" ;

/* generic args on paths: lifetimes, types, consts, bindings, and (contextually) constraints */
genericArgs       -> "<" genericArg ("," genericArg)* ","? ">"
                   | "::" "<" genericArg ("," genericArg)* ","? ">" ;

genericArg        -> LIFETIME
                   | type
                   | genericArgsConst
                   | genericArgsBinding
                   | constrainedTypeParam ;

/* const args: grammar-level expression; evaluator enforces const-evaluable */
genericArgsConst  -> expression ;

/* equality binding: e.g., Item<'a> = T */
genericArgsBinding -> IDENTIFIER genericArgs? "=" type ;

/* constrained type param (allowed contextually in bounds, like Item: Trait) */
constrainedTypeParam -> IDENTIFIER genericArgs? ":" typeParamBounds ;

/* ------------------------------------------------------------------------- */
/* Visibility                                                                 */
/* ------------------------------------------------------------------------- */

visibility        -> "pub" ("(" ("crate" | "self" | "super" | "in" simplePath) ")")? ;

/* ------------------------------------------------------------------------- */
/* Types                                                                      */
/* ------------------------------------------------------------------------- */

type              -> typeNoBounds
                   | implTraitType
                   | traitObjectType ;

typeNoBounds      -> parenthesizedType
                   | implTraitTypeOneBound
                   | traitObjectTypeOneBound
                   | typePath
                   | tupleType
                   | neverType
                   | rawPointerType
                   | referenceType
                   | arrayType
                   | sliceType
                   | inferredType
                   | qualifiedPathInType
                   | bareFunctionType
                   | macroInvocation ;

parenthesizedType -> "(" type ")" ;

tupleType         -> "(" ")"
                   | "(" (type ",")+ type? ")" ;

neverType         -> "!" ;

rawPointerType    -> "*" ("mut" | "const") typeNoBounds ;
referenceType     -> "&" LIFETIME? "mut"? typeNoBounds ;

arrayType         -> "[" type ";" expression "]" ;
sliceType         -> "[" type "]" ;
inferredType      -> "_" ;

qualifiedPathInType -> qualifiedPathType ("::" typePath)? ;
qualifiedPathType  -> "<" type ("as" typePath)? ">" ;

/* Note: no turbofish '::<' in type paths */
typePath          -> "::"? typePathSegment ("::" typePathSegment)* ;
typePathSegment   -> pathIdentSegment genericArgs? ;

/* ------------------------------------------------------------------------- */
/* Paths in expressions                                                       */
/* ------------------------------------------------------------------------- */

simplePath        -> "::"? simplePathSegment ("::" simplePathSegment)* ;
simplePathSegment -> IDENTIFIER | "super" | "self" | "crate" | "$crate" ;

pathInExpression  -> "::"? pathExprSegment ("::" pathExprSegment)* ;
pathExprSegment   -> pathIdentSegment ("::" genericArgs)? ;
pathIdentSegment  -> IDENTIFIER | "super" | "self" | "Self" | "crate" | "$crate" ;

qualifiedPathInExpression -> qualifiedPathType ("::" pathExprSegment)+ ;

/* ------------------------------------------------------------------------- */
/* Patterns                                                                  */
/* ------------------------------------------------------------------------- */

pattern           -> "|"? patternNoTopAlt ("|" patternNoTopAlt)* ;

patternNoTopAlt   -> patternWithoutRange
                   | rangePattern ;

patternWithoutRange
                  -> literalPattern
                   | identifierPattern
                   | wildcardPattern
                   | restPattern
                   | referencePattern
                   | structPattern
                   | tupleStructPattern
                   | tuplePattern
                   | groupedPattern
                   | slicePattern
                   | pathPattern
                   | macroInvocation ;

literalPattern    -> "true" | "false"
                   | CHAR
                   | BYTE
                   | STRING
                   | RAW_STRING
                   | BYTE_STRING
                   | RAW_BYTE_STRING
                   | C_STRING
                   | RAW_C_STRING
                   | INTEGER
                   | FLOAT
                   | "-" INTEGER
                   | "-" FLOAT ;

identifierPattern -> "ref"? "mut"? IDENTIFIER ("@" patternNoTopAlt)? ;
wildcardPattern   -> "_" ;
restPattern       -> ".." ;
referencePattern  -> ("&" | "&&") "mut"? patternWithoutRange ;

structPattern     -> pathInExpression "{" structPatternElements? "}" ;
structPatternElements
                  -> structPatternFields ("," structPatternEtCetera?)?
                   | structPatternEtCetera ;
structPatternFields -> structPatternField ("," structPatternField)* ;
structPatternField -> outerAttr* (tupleIndex ":" patternNoTopAlt
                                  | IDENTIFIER ":" patternNoTopAlt
                                  | "ref"? "mut"? IDENTIFIER) ;
structPatternEtCetera -> outerAttr* ".." ;

tupleStructPattern -> pathInExpression "(" tuplePatternItems? ")" ;
tuplePattern      -> "(" tuplePatternItems? ")" ;
tuplePatternItems -> pattern ("," pattern)* ","?
                   | restPattern ("," pattern)+ ","?
                   | pattern ("," pattern)* "," restPattern ("," pattern)* ","? ;

groupedPattern    -> "(" pattern ")" ;
slicePattern      -> "[" slicePatternItems? "]" ;
slicePatternItems -> pattern ("," pattern)* ","? ;

pathPattern       -> pathInExpression
                   | qualifiedPathInExpression ;

rangePattern      -> rangePatternBound ("..=" | "...") rangePatternBound
                   | rangeInclusiveStart
                   | obsoleteRangePattern ;

rangePatternBound -> CHAR | BYTE | "-"? INTEGER | "-"? FLOAT | pathInExpression ;
rangeInclusiveStart -> rangePatternBound "..=" ;
obsoleteRangePattern -> rangePatternBound "..." ;

/* ------------------------------------------------------------------------- */
/* Statements                                                                 */
/* ------------------------------------------------------------------------- */

statement         -> ";"
                   | item
                   | letStatement
                   | expressionStatement
                   | macroInvocationSemi ;

letStatement      -> outerAttr* "let" patternNoTopAlt (":" type)? ("=" expression ("else" blockExpr)?)? ";" ;
expressionStatement -> expressionWithoutBlock ";"
                     | expressionWithBlock ";"? ;

/* ------------------------------------------------------------------------- */
/* Macro invocations in expr/stmt                                             */
/* ------------------------------------------------------------------------- */

macroInvocationSemi -> simplePath "!" delimTokenTree ";" ;

/* ------------------------------------------------------------------------- */
/* Expressions                                                                */
/* ------------------------------------------------------------------------- */

expression        -> assignment ;
assignment        -> (rangeExpr assignOp)* rangeExpr ;
assignOp          -> "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" ;

rangeExpr         -> logicalOr (rangeOp logicalOr?)? ;
rangeOp           -> ".." | "..=" ;

logicalOr         -> logicalAnd ("||" logicalAnd)* ;
logicalAnd        -> comparison ("&&" comparison)* ;

comparison        -> bitwiseOr (comparisonOp bitwiseOr)* ;
comparisonOp      -> "==" | "!=" | "<" | "<=" | ">" | ">=" ;

bitwiseOr         -> bitwiseXor ("|" bitwiseXor)* ;
bitwiseXor        -> bitwiseAnd ("^" bitwiseAnd)* ;
bitwiseAnd        -> shift ("&" shift)* ;

shift             -> term (shiftOp term)* ;
shiftOp           -> "<<" | ">>" ;

term              -> factor (termOp factor)* ;
termOp            -> "+" | "-" ;

factor            -> cast (factorOp cast)* ;
factorOp          -> "*" | "/" | "%" ;

cast              -> unary ("as" typeNoBounds)* ;

unary             -> unaryOp* postfix ;
unaryOp           -> "-" | "!" | "*" | "&" "mut"? | "&&" "mut"? ;

postfix           -> primary postfixOp* ;
postfixOp         -> callOp
                   | methodCallOp
                   | fieldAccessOp
                   | tupleIndexOp
                   | indexOp
                   | awaitOp
                   | tryOp ;

callOp            -> "(" callParams? ")" ;
methodCallOp      -> "." pathExprSegment "(" callParams? ")" ;
fieldAccessOp     -> "." IDENTIFIER ;
tupleIndexOp      -> "." INTEGER ;
indexOp           -> "[" expression "]" ;
awaitOp           -> "." "await" ;
tryOp             -> "?" ;

callParams        -> expression ("," expression)* ","? ;

primary           -> literalExpr
                   | pathExpr
                   | groupedExpr
                   | arrayExpr
                   | tupleExpr
                   | structExpr
                   | closureExpr
                   | blockExpr
                   | asyncBlockExpr
                   | unsafeBlockExpr
                   | loopExpr
                   | ifExpr
                   | ifLetExpr
                   | matchExpr
                   | continueExpr
                   | breakExpr
                   | returnExpr
                   | underscoreExpr
                   | macroInvocation ;

literalExpr       -> CHAR
                   | STRING
                   | RAW_STRING
                   | BYTE
                   | BYTE_STRING
                   | RAW_BYTE_STRING
                   | C_STRING
                   | RAW_C_STRING
                   | INTEGER
                   | FLOAT
                   | "true"
                   | "false" ;

pathExpr          -> pathInExpression
                   | qualifiedPathInExpression ;

groupedExpr       -> "(" innerAttr* expression ")" ;

arrayExpr         -> "[" arrayElements? "]" ;
arrayElements     -> expression (";" expression | ("," expression)* ","?) ;

tupleExpr         -> "(" innerAttr* tupleElements? ")" ;
tupleElements     -> (expression ",")+ expression? ;

structExpr        -> structExprStruct
                   | structExprTuple
                   | structExprUnit ;

structExprStruct  -> pathInExpression "{" (structExprFields | structBase)? "}" ;
structExprFields  -> structExprField ("," structExprField)* ("," structBase | ","?) ;
structExprField   -> outerAttr* (IDENTIFIER | (IDENTIFIER | tupleIndex) ":" expression) ;
structBase        -> ".." expression ;

structExprTuple   -> pathInExpression "(" (expression ("," expression)* ","?)? ")" ;
structExprUnit    -> pathInExpression ;

closureExpr       -> "move"? "async"? ("||" | "|" closureParams? "|") (expression | "->" typeNoBounds blockExpr) ;
closureParams     -> closureParam ("," closureParam)* ","? ;
closureParam      -> outerAttr* patternNoTopAlt (":" type)? ;

blockExpr         -> "{" innerAttr* statements? "}" ;
asyncBlockExpr    -> "async" "move"? blockExpr ;
unsafeBlockExpr   -> "unsafe" blockExpr ;

statements        -> statement+ expression?
                   | expression ;

loopExpr          -> infiniteLoopExpr
                   | predicateLoopExpr
                   | predicatePatternLoopExpr
                   | iteratorLoopExpr
                   | labelBlockExpr ;

infiniteLoopExpr  -> loopLabel? "loop" blockExpr ;
predicateLoopExpr -> loopLabel? "while" expression blockExpr ;
predicatePatternLoopExpr -> loopLabel? "while" "let" pattern "=" scrutinee blockExpr ;
iteratorLoopExpr  -> loopLabel? "for" pattern "in" expression blockExpr ;
loopLabel         -> LIFETIME ":" ;
labelBlockExpr    -> loopLabel blockExpr ;

scrutinee         -> expression ;

ifExpr            -> "if" expression blockExpr ("else" (blockExpr | ifExpr | ifLetExpr))? ;
ifLetExpr         -> "if" "let" pattern "=" scrutinee blockExpr ("else" (blockExpr | ifExpr | ifLetExpr))? ;

matchExpr         -> "match" scrutinee "{" innerAttr* matchArms? "}" ;
matchArms         -> (matchArm "=>" (expressionWithoutBlock "," | expressionWithBlock ","?))* matchArm "=>" expression ","? ;
matchArm          -> outerAttr* pattern matchArmGuard? ;
matchArmGuard     -> "if" expression ;

continueExpr      -> "continue" LIFETIME? ;
breakExpr         -> "break" LIFETIME? expression? ;
returnExpr        -> "return" expression? ;
underscoreExpr    -> "_" ;

expressionWithoutBlock -> outerAttr* expressionKind ;
expressionWithBlock -> outerAttr* expressionKindWithBlock ;

expressionKind    -> literalExpr
                   | pathExpr
                   | groupedExpr
                   | arrayExpr
                   | tupleExpr
                   | structExpr
                   | closureExpr
                   | continueExpr
                   | breakExpr
                   | returnExpr
                   | underscoreExpr
                   | macroInvocation ;

expressionKindWithBlock
                  -> blockExpr
                   | asyncBlockExpr
                   | unsafeBlockExpr
                   | loopExpr
                   | ifExpr
                   | ifLetExpr
                   | matchExpr ;

/* ------------------------------------------------------------------------- */
/* Macro invocation (expr/stmt/type)                                         */
/* ------------------------------------------------------------------------- */

macroInvocation   -> simplePath "!" delimTokenTree ;

/* ------------------------------------------------------------------------- */
/* Tokens                                                                     */
/* ------------------------------------------------------------------------- */

tokenStream       -> tokenTree* ;
tokenTree         -> tokenExceptDelims
                   | delimTokenTree ;

tupleIndex        -> INTEGER ;

/* ------------------------------------------------------------------------- */
/* Notes (semantic constraints not expressible in pure context-free form)     */
/* - associatedConstItem: '=' is required in impls, optional in traits.       */
/* - constrainedTypeParam in genericArgs is only accepted in bound contexts   */
/*   (e.g., impl Trait / dyn Trait), not arbitrary type paths.                */
/* - const args must be const-evaluable; grammar accepts 'expression' but     */
/*   the evaluator enforces the subset.                                       */
/* - turbofish '::<' is for expressions; types do not use it.                 */
/* ------------------------------------------------------------------------- */

