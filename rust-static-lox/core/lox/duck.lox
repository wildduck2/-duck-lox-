//let ref mut x @ _: i32 = 1;
//let ref mut _ @ _: i32 = 1;
//let ref mut _ @ x: i32 = 1;
//let a @ ref b = x;
//let a @ ref mut b = x;
//let ref a @ ref b = x;
//let (ref x) @ (ref y) = t;

//let [] = v;
//
//let [a] = v;
//let [a, b] = v;
//let [a, b, c] = v;
//
//let [a, ..] = v;
//let [a, b, ..] = v;
//
//let [..] = v;
//let [.., a] = v;
//let [.., a, b] = v;
//
//let [a, .., b] = v;
//let [a, .., b, c] = v;
//
//let [a, ..rest] = v;
//let [a, b, ..rest] = v;
//
//let [..rest] = v;
//let [..rest, a] = v;
//let [..rest, a, b] = v;
//
//let [a, ..rest, b] = v;
//let [a, ..rest, b, c] = v;
//
//let [Some(a), ..] = v;
//let [Some::HELL(a), ..] = v;
//let [<T>::Some(a), ..] = v;
//let [<TYPE as ::path::Trait>::Item(x, y), ..] = v;
//let [ <T as ::path::Trait>::Some { #[some_attribute] name: Some(x), .. }, ..] = v;
//let (x, y) = v;
//let [(y, x), ..rest] = v;
//let [(a, b), .., (c, d)] = v;
//let [ref a, .., ref mut b] = v;
//let [x @ Some(_), ..rest] = v;

//referencePattern  -> ("&" | "&&") "mut"? patternWithoutRange ;
//match x {
//  // true => 0,
//  // ref mut x @ _ => 0,
//  // _ => 0,
//  // .. => 0,
//  // &x => 0,
//  // &&x => 0,
//}

//match value {
//  // --- simple named-field structs ---
//
//  Point { x, y } => 0,
//  Point { x: a, y: b } => 1,
//  Point { x: 0, y } => 2,
//  Point { x, y: _ } => 3,
//
//  // --- using `..` rest ---
//
//  Point { x, .. } => 4,
//  Point { .. } => 5,
//
//  // --- mix of explicit + rest ---
//
//  Point { x: 10, .. } => 6,
//  Point { y, .. } => 7,
//
//
//  // --- ref / ref mut on fields (shorthand) ---
// 
//  Point { .. } => 10,
//  Point { ref x } => 10,
//  Point { ref mut x } => 10,
//  Point { ref x, ref y } => 10,
//  Point { ref mut x, y } => 11,
//  Point { ref x, ref mut y } => 12,
//
//  // --- ref / ref mut with explicit field names ---
//
//  Point { x: ref xr, y: ref yr } => 13,
//  Point { x: ref mut xr, y } => 14,
//  Point { x, y: ref mut yr } => 15,
//
//  // --- nested struct patterns ---
//
//  Rect {
//      top_left: Point { x: 0, y },
//      bottom_right: Point { x: bx, y: by },
//  } => 16,
//
//  Rect {
//      top_left: Point { x, y },
//      bottom_right,
//  } => 17,
//
//  // --- nested + rest ---
//
//  Rect {
//      top_left: Point { x, .. },
//      ..
//  } => 18,
//
//  // --- attribute on a struct field in pattern ---
//
//  S {
//      #[cfg(test)]
//      x,
//      y,
//  } => 19,
//
//  // --- wildcard fallback ---
//
//   _ => 100,
//}

//match value {
//    // -------------------------------
//    // Basic field patterns
//    // -------------------------------
//    Point { x, y } => 0,
//    Point { x: a, y: b } => 1,
//    Point { x: 0, y } => 2,
//    Point { x, y: _ } => 3,
//    Point { x: 10, y: 20 } => 4,
//
//    // -------------------------------
//    // Shorthand + explicit mix
//    // -------------------------------
//    Point { x, y: b } => 5,
//    Point { x: a, y } => 6,
//
//    // -------------------------------
//    // Tuple index struct fields
//    // -------------------------------
//    //Color { 0: r, 1: g, 2: b } => 7,
//    //Color { 0: r, .. } => 8,
//    //Color { 1: _, 2: val } => 9,
//
//    // -------------------------------
//    // Rest patterns
//    // -------------------------------
//    Point { x, .. } => 10,
//    Point { .. } => 11,
//    Point { x: 5, .. } => 12,
//    Point { x, y, .. } => 13,
//    Point { .., } => 14,   // trailing comma allowed
//
//    // -------------------------------
//    // Attributes on fields
//    // -------------------------------
//    Point {
//        #[cfg(test)]
//        x,
//        y,
//    } => 15,
//
//    Point {
//        #[inline(always)]
//        x: px,
//        #[cfg(feature = "f")]
//        y: py,
//    } => 16,
//
//    // -------------------------------
//    // Attributes on the rest (`..`)
//    // -------------------------------
//    Point {
//        x,
//        #[cfg(debug_assertions)]
//        ..
//    } => 17,
//
//    // -------------------------------
//    // Ref/ref mut bindings (shorthand)
//    // -------------------------------
//    Point { ref x } => 18,
//    Point { ref mut x } => 19,
//    Point { ref x, ref y } => 20,
//    Point { ref mut x, y } => 21,
//    Point { x, ref mut y } => 22,
//
//    // -------------------------------
//    // Ref/ref mut with explicit field names
//    // -------------------------------
//    Point { x: ref px, y: ref py } => 23,
//    Point { x: ref mut px, y } => 24,
//    Point { x, y: ref mut py } => 25,
//
//    // -------------------------------
//    // More complex patterns inside fields
//    // -------------------------------
//    Point { x: Some(v), y: None } => 26,
//    Point { x: &v, y: &&mut z } => 27,
//    Point { x: (a, b), y: Point { x: inner, .. } } => 28,
//
//    // -------------------------------
//    // Nested struct patterns
//    // -------------------------------
//    Rect {
//        top_left: Point { x, y },
//        bottom_right: Point { x: bx, y: by },
//    } => 29,
//
//    Rect {
//        top_left: Point { x: 0, y },
//        bottom_right,
//    } => 30,
//
//    // Nested + rest
//    Rect {
//        top_left: Point { x, .. },
//        bottom_right: Point { y, .. },
//        ..
//    } => 31,
//
//    // -------------------------------
//    // Only rest inside nested pattern
//    // -------------------------------
//    Wrapper {
//        item: Point { .. },
//    } => 32,
//
//    // -------------------------------
//    // Multiple field attributes + rest
//    // -------------------------------
//    Point {
//        #[cfg(test)]
//        x: ref a,
//        #[allow(dead_code)]
//        y: ref mut b,
//        #[inline]
//        ..
//    } => 33,
//
//    // -------------------------------
//    // Final fallback
//    // -------------------------------
//    _ => 100,
//}

//match value {
//    // -----------------------------------------
//    // Empty tuple
//    // -----------------------------------------
//    () => 0,
//
//    // -----------------------------------------
//    // Single element tuple
//    // -----------------------------------------
//    (x,) => 1,
//    (0,) => 2,
//    (_, ) => 3,
//
//    // -----------------------------------------
//    // Multiple element patterns
//    // -----------------------------------------
//    (a, b) => 4,
//    (x, y, z) => 5,
//    (x, 10, _) => 6,
//    (&a, &mut b) => 7,
//
//    // -----------------------------------------
//    // Nested tuples
//    // -----------------------------------------
//    ((a, b), (c, d)) => 8,
//    (Point { x, .. }, (m, n)) => 9,
//
//    // -----------------------------------------
//    // Tuple struct basic
//    // -----------------------------------------
//    Foo() => 10,
//    Foo(x,) => 11,
//    Foo(x, y) => 12,
//    Foo(1, 2, 3) => 13,
//
//    // -----------------------------------------
//    // Tuple struct with nested patterns
//    // -----------------------------------------
//    Bar(Some(v), None) => 14,
//    Baz((a, b), Point { x, .. }) => 15,
//
//    // -----------------------------------------
//    // Rest-only tuple pattern
//    //   restPattern -> ".."
//    // -----------------------------------------
//    (.., a) => 16,      // rest first
//    (a, ..) => 17,      // rest last
//    (..,) => 18,        // only rest + trailing comma
//
//    // -----------------------------------------
//    // tuplePatternItems rule #1:
//    // pattern (',' pattern)* ','?
//    // -----------------------------------------
//    (a, b,) => 19,
//    (_, _, _,) => 20,
//
//    // -----------------------------------------
//    // tuplePatternItems rule #2:
//    // restPattern (',' pattern)+ ','?
//    // -----------------------------------------
//    (.., x) => 21,
//    (.., a, b) => 22,
//    (.., a, b,) => 23,
//
//    // -----------------------------------------
//    // tuplePatternItems rule #3:
//    // pattern (',' pattern)* ',' rest (',' pattern)* ','?
//    // -----------------------------------------
//    (a, .., b) => 24,
//    (a, b, .., c, d) => 25,
//    (x, y, .., z,) => 26,
//
//    // -----------------------------------------
//    // Named rest (identifier after dot-dot)
//    // These are valid in patterns:  "..ident"
//    // -----------------------------------------
//    (a, ..rest) => 27,
//    (..rest, a) => 28,
//    (x, ..mid, y) => 29,
//
//    // -----------------------------------------
//    // Binding rest with @
//    // x @ .., x @ ..rest
//    // -----------------------------------------
//    (head @ .., x) => 30,
//    (a, tail @ ..) => 31,
//    (a, mid @ ..rest, b) => 32,
//
//    // -----------------------------------------
//    // Tuple struct with rest
//    // -----------------------------------------
//    Foo(..) => 33,
//    Foo(.., x) => 34,
//    Foo(a, ..) => 35,
//    Foo(a, .., b) => 36,
//    Foo(..rest, x) => 37,
//    Foo(a, rest @ .., b) => 38,
//
//    // -----------------------------------------
//    // Complex mixed patterns
//    // -----------------------------------------
//    (Some(x), None, .., Point { y, .. }, z) => 39,
//
//    // -----------------------------------------
//    // Wildcard fallback
//    // -----------------------------------------
//    _ => 999,
//}

//match value {
//    // ========================================
//    // Slice patterns — basic
//    // ========================================
//
//    [] => 0,
//    [x] => 1,
//    [x,] => 2,                // trailing comma allowed
//    [x, y] => 3,
//    [x, y,] => 4,
//    [a, b, c] => 5,
//    [a, b, c,] => 6,
//
//    // Slice patterns — mixed types
//    [0, 1, 2] => 7,
//    [true, false] => 8,
//    ["hi", s] => 9,
//
//    // Slice patterns — nested patterns
//    [(a, b)] => 10,
//    [[x, y]] => 11,
//    [Point { x, .. }] => 12,
//
//    // Slice patterns — pattern expressions inside
//    [&x] => 13,
//    [&mut y] => 14,
//    [Some(v)] => 15,
//    [Ok(val)] => 16,
//    [Err(e)] => 17,
//
//    // ========================================
//    // Path patterns
//    // ========================================
//
//    // Simple identifiers
//    Unit => 20,
//    Value => 21,
//    MyEnum => 22,
//
//    // Simple paths
//    module::Type => 23,
//    foo::bar::Baz => 24,
//
//    // Enum variant path patterns
//    Some(x) => 25,
//    Option::Some(v) => 26,
//    std::option::Option::None => 27,
//    crate::my_mod::MyEnum::Variant => 28,
//
//    // Tuple-struct patterns as path patterns
//    Point(x, y) => 29,
//    crate::math::Point(a, b) => 30,
//    std::ops::Range(start, end) => 31,
//
//    // Struct patterns count as pathPattern because they start with a path
//    PathStruct { x, y } => 32,
//    module::Nested { a, b: inner } => 33,
//
//    // Qualified path items (fully qualified syntax)
//    <T as Trait>::CONST => 40,
//    <Type as Trait>::Variant(x) => 41,
//    <Self as Trait>::Method(a) => 42,
//    <Vec<T> as SliceExt>::slice_pattern => 43,
//
//    // Qualified tuple-struct pattern
//    <S as IntoIterator>::Item(x, y) => 44,
//
//    // Qualified struct pattern
//    <MyType as Trait>::Assoc { field } => 45,
//
//    // Path with generic arguments
//    Vec::<i32> => 50,
//    std::option::Option::<T>::Some(x) => 51,
//    o::Bar::<T, U> => 52,
//
//    // Path to consts
//    MAX => 60,
//    std::f32::consts::PI => 61,
//
//    // Fallback
//    _ => 999,
//}


//match value {
//   // ─────────────────────────────────────────
//   // 1. Macro as a full pattern
//   // ─────────────────────────────────────────
//   mypat!() => 1,
//   foo!(x) => 2,
//   bar! { x, y } => 3,
//   baz![a, b, c] => 4,
//
//   // ─────────────────────────────────────────
//   // 2. Macro inside tuple patterns
//   // ─────────────────────────────────────────
//   (mypat!()) => 10,
//   (x, macro!(y), z) => 11,
//   (foo!(),) => 12,
//
//   // Nested tuple
//   ((inner!()), rest) => 13,
//
//   // ─────────────────────────────────────────
//   // 3. Macro inside slice patterns
//   // ─────────────────────────────────────────
//   [m!()] => 20,
//   [x, pat!(), y] => 21,
//   [head, mac![sub], tail] => 22,
//
//   // ─────────────────────────────────────────
//   // 4. Macro inside struct patterns
//   // ─────────────────────────────────────────
//   Point { x: val!(), y } => 30,
//   Pair { left: foo!(abc), right } => 31,
//
//   // ─────────────────────────────────────────
//   // 5. Macro inside tuple-struct patterns
//   // ─────────────────────────────────────────
//   Some(foo!()) => 40,
//   Result::Ok(bar![x]) => 41,
//   Pair(inner!(1), inner!(2)) => 42,
//
//   // ─────────────────────────────────────────
//   // 6. Macro inside reference patterns
//   // ─────────────────────────────────────────
//   &mac!() => 50,
//   &&foo!(pat) => 51,
//   &mut bar!() => 52,
//
//   // ─────────────────────────────────────────
//   // 7. Macro inside OR-patterns
//   // ─────────────────────────────────────────
//   mac!() | other!() => 60,
//   a | m!(x) | b => 61,
//
//   // ─────────────────────────────────────────
//   // 8. Macro inside @ bindings
//   // ─────────────────────────────────────────
//   var @ mac!() => 70,
//   left @ foo!(x) => 71,
//
//   // Nested:
//   (outer @ m!(inner)) => 72,
//
//   // ─────────────────────────────────────────
//   // 9. Macro inside grouped patterns
//   // ─────────────────────────────────────────
//   (m!()) => 80,
//   ((x, y, z), mac!()) => 81,
//
//   // Mixed grouping
//   (((foo!()))) => 82,
//
//   // ─────────────────────────────────────────
//   // 10. Macro mixed with literals
//   // ─────────────────────────────────────────
//   [1, mac!(), 3] => 90,
//   (true, m!(), false) => 91,
//
//   // ─────────────────────────────────────────
//   // 11. Macro inside pattern guards
//   // (not pattern, but your `guard -> if expression`)
//   // ─────────────────────────────────────────
//
//   // ─────────────────────────────────────────
//   // 12. Final fallback
//   // ─────────────────────────────────────────
//   _ => 999,
//}


