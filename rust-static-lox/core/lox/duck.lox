//3.14;
//3.14f32;
//1e6;
//1.0e-5;
//1.4E2f32;
//
//111111u8;
//0xFF;
//0o777;
//0b1010;
//
//
//"escape\nsequence\tand quotes\"ok\"";
//
//r"no escapes here; \n stays \n";
//r#"contains "quotes" safely"#;
//r##"even # symbols are fine"##;
//
//b"abc";
//b"with\x20spaces";
//
//br"raw bytes";
//br#"with "quotes" inside"#;
//
//c"hello from C";
//cr#"raw C string"# ;
//cr##"raw C string with # inside"##;
//
//"Hello, World!";
//r"raw string";
//r#"raw with "quotes""#;
//r##"multi#hash raw"##;
//b"Hello\x20World";
//br"raw bytes";
//br##"raw bytes with # inside"##;
//c"Hello, C-string!";
//cr#"raw C-string"#;
//cr###"multi-hash raw C-string"###;
//
//b'A';
//b'a';
//
//name;
//welcome;
//identifier;
//
//true;
//false;
//
//foo.bar;
//person.name;
//config.value;
//
//tuple.0;
//point.1;
//pair.2;
//
//arr[0];
//arr[i * 1];
//matrix[1][2];
//foo[bar.baz];
//
//foo(1);
//foo(1, 2, 3);
//bar("hi", true);
//nested(outer(1), 2);
//
//add(1 * 2);
//
//foo.bar();
//foo.bar(1, 2);
//obj.method("hi", true);
//obj.method().other();
//self.compute().finish();
//
//future.await;
//foo.bar().await;
//read_file().await;
//x[0].await;
//
//foo()?;
//read_line()?.trim();
//get_value()?.to_string()?;
//arr[0]?;
//
//foo.bar().baz[0].qux().await?;
//tuple.0.call_method(42)[i].await;
//get_data()[index].field.call()?.another_call(1);
//user.info().friends[0].send_message("hi")?;
//
//-x;
//!flag;
//*ptr;
//&x;
//&mut y;
//&&ptr;
//&&mut ref_to_value;
//
//--x      ;     // double negation
//!!enabled;     // double logical not
//*&x      ;     // deref a reference
//*&mut y  ;     // deref a mutable reference
//&&*&mut z;     // layered: ref->ref->deref->mut
//-&*ptr   ;     // negation applied to deref’d pointer
//!*ptr    ;     // not of deref’d boolean
//&&mut *&x;     // ref→mut→deref→ref→ident
//
//-&foo.bar;     // negation + ref + field access
//!*data[0];     // logical not + deref + index
//&mut arr[1].value;
//&&mut *obj.method();
//-*&mut config.option()?.await;
//
//--value.call()?;
//!array[0].field.await;
//*&mut obj.method(1, 2);
//&&mut *&nested.field[2].call()?.await;
//
//
//a * b;
//x / y;
//n % 2;
//a * b / c % d;
//x * y / (z % w);
//
//1 * 2;
//(a / b);
//(1 / 2) * 3;
//x * (y / z);
//(x * (y / (z * w)));
//(*ptr).method();
//(&mut (arr[i / 1])).await;
//
//a as f32 * b
//x / (y as i64)
//z % (w as u8)
//
//(1 as f32) * (2 as f64)
//a * (b as i32) / (c % d as u16)
//(x as f32 * y as f64) / (z as f64)
//
//a * b as f32        // cast applies to b
//(a * b) as f32      // cast applies to result
//1 / 2 as f64        // should parse as 1 / (2 as f64)
//(1 / 2) as f64      // should cast entire division
//
//1 + 2
//a - b
//
//x + y - z
//1 + 2 * 3
//4 - 5 / 6
//7 % 8 + 9
//a * b + c / d
//x + y * z - w
//
//(1 + 2) * 3
//4 * (5 - 6)
//(7 + 8) / (9 - 10)
//a + b as f32
//(a + b) as f32
//
//x as f32 - y
//(x - y) as f64
//(1 + 2 as f32) * 3
//1 + (2 as f32 * 3)
//1 + 2 * 3 - 4 / 5 % 6
//
//(a as f32 + b * c as f64) / (d - e as i32)
//x - y + z * (w as f32 / 2)
//(1 + 2) as f32 + 3
//((a - b) * (c + d as i32)) as f64
//a + (b as f32 + (c * (d as f64)))
//
//a << b
//x >> y
//val << 2
//num >> 3
//
//a << b << c
//x >> y >> z
//a << b >> c
//a + b << c
//
//x >> y - z
//1 + 2 << 3 - 4
//(a + b) << (c - d)
//
//a * b << c / d
//x >> y * z
//(1 * 2) << (3 / 4)
//
//a << b as u32
//(x as u64) >> y
//(a << b) as u8
//x >> (y as usize)
//
//(1 as i32) << (2 as i8)
//((a + b) << (c - d)) >> (e * f)
//(((x as i32) << 1) + (y as i32)) >> 2
//
//*&x << *&y
//-&a >> &mut b
//!flag << 1
//
//((a * b + c as i32) << (d - e)) >> (f / g as u8)
//((x as i64) >> (y + z * w)) + (q << (r as i32))
//
//a & b
//x ^ y
//p | q
//
//a & b & c
//x ^ y ^ z
//a | b | c
//
//a & b ^ c | d
//x | y & z ^ w
//a ^ b | c & d
//
//a & b ^ c | d  //→  ((a & b) ^ c) | d
//a << b & c >> d
//x ^ y << z
//a | b >> c
//
//a + b & c - d
//x * y ^ z / w
//p | q + r
//(1 + 2) & (3 ^ 4 | 5)
//
//a & (b as u32)
//(x ^ y) as i64
//a | b as u8
//
//(a + b & c ^ (d | e << f)) >> g
//(x ^ (y & (z | (w << 1)))) + q
//((a | b) & (c ^ d)) << (e | f)
//


