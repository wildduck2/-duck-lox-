// character literals
//'a'
//'ðŸ¦€'
//'\n'
//'\u{1F980}'
//'x

// string literals
"hello"
"foo\nbar"
"multi
line"
"unterminated


// byte literal (single ascii byte)
b'a'
b'\n'
b'\x7F'
b' \t\n'

// Valid ASCII byte literals
b'a'
b'Z'
b'_'
b' '
b'0'

// Escaped forms
b'\n'
b'\r'
b'\t'
b'\\'
b'\''
b'\"'
b'\0'

// Hexadecimal escapes
b'\x00'
b'\x41'
b'\x7F'

//// Invalid / malformed cases
//b'a
//b'\n
//b'\x7F
//b''
//b'ðŸ¦€'
//b'\u{1F980}'
//b'ab'

// Basic ASCII
b"hello"
b"HELLO"
b"12345"
b"abc_def"
b" "            // single space
b"!@#$%^&*()"   // punctuation

// With escapes
b"\n"
b"\t"
b"\r"
b"\\"
b"\""
b"\0"
b"\x41\x42\x43"     // "ABC"

// Multi-line (if supported)
b"line1\nline2"

// With underscores (allowed inside escapes)
b"abc_\x41_123"

// Long but valid
b"The quick brown fox jumps over the lazy dog"

// Empty
b""

// Invalid because contains non-ASCII
// b"ðŸ¦€"

// Invalid escape
// b"\xG1"

// Incomplete hex escape
// b"\x4"

// Unterminated
// b"hello
// b"\x41

// Invalid prefix (should be b" not just b)
// b
// b"

// Missing closing quote
// b"abc



// =========================================
// C String Literal Tests
// =========================================

// âœ… VALID C STRING LITERALS
// Basic
c"hello"
c"HELLO_WORLD"
c"12345"
c"!@#$%^&*()"
c"with spaces"
c"trailing\0"      // explicit null
c"contains\0nulls"
c"multi_part_string"

// Escapes
c"\n"
c"\t"
c"\r"
c"\\"
c"\""
c"\0"

// With embedded sequences
c"line1\nline2\r\n"
c"path\\to\\file"
c"quote:\"hello\""

// Empty string
c""

// Explicit nulls at the end
c"end\0"
c"middle\0of\0string"

// =========================================
// âš ï¸ INVALID / MALFORMED EXAMPLES
// =========================================

// Missing closing quote
// c"unterminated

// Invalid Unicode (C strings are ASCII / UTF-8, but may allow it depending on implementation)
// c"ðŸ¦€"

// Newline inside literal (if not escaped)
// c"this
// string"

// Unescaped backslash at end
// c"ends with \

// Explicitly missing null terminator (should still be valid, but check behavior)
c"non_null_terminated"

// Double quotes inside without escape
// c"bad"quote"

// =========================================
// âœ… EDGE CASES
// =========================================

// Explicit double null
c"\0\0"

// String with mix of escaped + null
c"ab\nc\0def"

// Long string
c"The quick brown fox jumps over the lazy dog"

// Escapes mixed with punctuation
c"hello\tworld!\n\\\"C\\\""

// Explicit embedded nulls mid-string
c"abc\0def\0ghi"

impl Lexer {
  pub fn lex_string(&mut self, engine: &mut DiagnosticEngine) -> Option<TokenKind> {
    if self.get_current_lexeme() == "b" && self.peek() == Some('\'') {
      return self.lex_bchar(engine);
    } else if self.get_current_lexeme() == "b" && self.peek() == Some('"') {
      return self.lex_bstr(engine);
    } else if self.get_current_lexeme() == "c" && self.peek() == Some('"') {
      return self.lex_cstr(engine);
    } else if self.get_current_lexeme() == "\'" {
      return self.lex_char(engine);
    } else if self.get_current_lexeme() == "\"" {
      return self.lex_str(engine);
    }

    Some(TokenKind::Literal {
      kind: LiteralKind::Str { terminated: false },
      suffix_start: 0,
    })
  }

  /// Consumes characters until the closing delimiter, handling escape sequences
  /// Returns true if properly terminated
  fn consume_until_delimiter(
    &mut self,
    delimiter: char,
    allow_escapes: bool,
  ) -> bool {
    while let Some(c) = self.peek() {
      // Stop at newline (unterminated)
      if c == '\n' {
        return false;
      }

      // Handle escape sequences
      if allow_escapes && c == '\\' {
        self.advance(); // consume backslash
        if let Some(escaped) = self.peek() {
          self.advance(); // consume escaped character
          // Special handling for unicode escapes in char literals
          if escaped == 'u' && self.peek() == Some('{') {
            self.advance(); // consume '{'
            // Consume until closing '}'
            while let Some(uc) = self.peek() {
              self.advance();
              if uc == '}' {
                break;
              }
            }
          }
        }
        continue;
      }

      // Check for closing delimiter
      if c == delimiter {
        self.advance();
        return true;
      }

      self.advance();
    }

    false
  }

  /// Emit an unterminated literal diagnostic
  fn emit_unterminated_diagnostic(
    &self,
    engine: &mut DiagnosticEngine,
    literal_type: &str,
    quote_type: &str,
  ) {
    let diagnostic = Diagnostic::new(
      DiagnosticCode::Error(DiagnosticError::UnterminatedString),
      format!("Unterminated {} literal: {}", literal_type, self.get_current_lexeme()),
      self.source.path.to_string(),
    )
    .with_label(
      diagnostic::Span::new(self.start, self.current),
      Some(format!("This {} literal is not terminated", literal_type)),
      LabelStyle::Primary,
    )
    .with_help(format!("Use {} for {} literals.", quote_type, literal_type));
    
    engine.add(diagnostic);
  }

  fn lex_cstr(&mut self, engine: &mut DiagnosticEngine) -> Option<TokenKind> {
    self.advance(); // consume 'c'
    
    let terminated = self.consume_until_delimiter('"', true);

    if !terminated {
      self.emit_unterminated_diagnostic(engine, "C string", "double quotes");
    }

    Some(TokenKind::Literal {
      kind: LiteralKind::CStr { terminated },
      suffix_start: self.current as u32,
    })
  }

  fn lex_bstr(&mut self, engine: &mut DiagnosticEngine) -> Option<TokenKind> {
    self.advance(); // consume 'b'
    
    let terminated = self.consume_until_delimiter('"', true);

    if !terminated {
      self.emit_unterminated_diagnostic(engine, "byte string", "double quotes");
    }

    Some(TokenKind::Literal {
      kind: LiteralKind::ByteStr { terminated },
      suffix_start: self.current as u32,
    })
  }

  fn lex_bchar(&mut self, engine: &mut DiagnosticEngine) -> Option<TokenKind> {
    self.advance(); // consume 'b'
    
    let start_pos = self.current;
    let terminated = self.consume_until_delimiter('\'', true);

    if !terminated {
      self.emit_unterminated_diagnostic(engine, "byte character", "single quotes");
      return Some(TokenKind::Literal {
        kind: LiteralKind::Byte { terminated: false },
        suffix_start: self.current as u32,
      });
    }

    // Validate byte char length (should be b'x' or b'\x')
    let content_len = self.current - start_pos - 1; // -1 for closing quote
    let lexeme = self.get_current_lexeme();
    
    // Check if it's an escape sequence
    let is_escape = lexeme.contains('\\');
    
    if content_len > 2 && !is_escape {
      let diagnostic = Diagnostic::new(
        DiagnosticCode::Error(DiagnosticError::UnterminatedString),
        format!("Too many characters in byte char literal: {}", lexeme),
        self.source.path.to_string(),
      )
      .with_label(
        diagnostic::Span::new(self.start, self.current),
        Some("This byte char literal is too long".to_string()),
        LabelStyle::Primary,
      )
      .with_help("Byte char literals can only contain a single ASCII character or escape sequence.".to_string());

      engine.add(diagnostic);
      return None;
    }

    Some(TokenKind::Literal {
      kind: LiteralKind::Byte { terminated },
      suffix_start: self.current as u32,
    })
  }

  fn lex_char(&mut self, engine: &mut DiagnosticEngine) -> Option<TokenKind> {
    let start_pos = self.current;
    let terminated = self.consume_until_delimiter('\'', true);

    if !terminated {
      let diagnostic = Diagnostic::new(
        DiagnosticCode::Error(DiagnosticError::InvalidCharacter),
        format!("Unterminated char literal: {}", self.get_current_lexeme()),
        self.source.path.to_string(),
      )
      .with_label(
        diagnostic::Span::new(self.start, self.current),
        Some("Unterminated character literal".to_string()),
        LabelStyle::Primary,
      )
      .with_help("Use single quotes for character literals.".to_string());

      engine.add(diagnostic);
      
      return Some(TokenKind::Literal {
        kind: LiteralKind::Char { terminated: false },
        suffix_start: self.current as u32,
      });
    }

    // Validate char length
    let lexeme = self.get_current_lexeme();
    let content_len = self.current - start_pos - 1; // -1 for closing quote
    
    // Check for unicode escape
    let is_unicode = lexeme.contains("\\u{");
    
    if content_len > 1 && !lexeme.contains('\\') {
      // Multiple characters without escape
      let diagnostic = Diagnostic::new(
        DiagnosticCode::Error(DiagnosticError::UnterminatedString),
        format!("Too many characters in char literal: {}", lexeme),
        self.source.path.to_string(),
      )
      .with_label(
        diagnostic::Span::new(self.start, self.current),
        Some("This char literal is too long".to_string()),
        LabelStyle::Primary,
      )
      .with_help("Char literals can only contain a single character or escape sequence.".to_string());

      engine.add(diagnostic);
      return None;
    } else if is_unicode && !lexeme.ends_with("}'") {
      // Malformed unicode escape
      let diagnostic = Diagnostic::new(
        DiagnosticCode::Error(DiagnosticError::UnterminatedString),
        format!("Invalid unicode escape: {}", lexeme),
        self.source.path.to_string(),
      )
      .with_label(
        diagnostic::Span::new(self.start, self.current),
        Some("Unicode escape sequence is not properly closed".to_string()),
        LabelStyle::Primary,
      )
      .with_help("Use the correct escape sequence format: \\u{HEXDIGITS} (e.g., \\u{1F980})".to_string());

      engine.add(diagnostic);
      return None;
    }

    Some(TokenKind::Literal {
      kind: LiteralKind::Char { terminated },
      suffix_start: self.current as u32,
    })
  }

  fn lex_str(&mut self, engine: &mut DiagnosticEngine) -> Option<TokenKind> {
    let terminated = self.consume_until_delimiter('"', true);

    if !terminated {
      self.emit_unterminated_diagnostic(engine, "string", "double quotes");
      return None;
    }

    Some(TokenKind::Literal {
      kind: LiteralKind::Str { terminated: true },
      suffix_start: self.current as u32,
    })
  }
}
