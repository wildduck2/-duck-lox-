# Building an AST Parser: A Complete Step-by-Step Lesson

## What We're Trying to Do

You have a stream of tokens like `8 + 5 * 6` broken down into individual pieces. Your job is to build a tree structure (an Abstract Syntax Tree) that represents the meaning and structure of that expression, respecting operator precedence and grouping.

Think of it like reading a sentence: "The quick brown fox jumps" isn't just a flat list of words—it has structure. The noun phrase "The quick brown fox" is a unit, and "jumps" is the action. Similarly, `8 + 5 * 6` isn't just a flat list—it has structure where `5 * 6` groups together (multiplication has higher precedence than addition).

## The Key Insight: Recursive Descent Parsing

The fundamental idea is that you process tokens from left to right, and **you use recursive function calls to handle different parts of the grammar**. When you need to parse something complex, you call another function that knows how to handle that complexity.

Here's the mental model: imagine you're reading a recipe. The recipe says "make a cake" → but what does that mean? You need to look up the cake recipe, which says "combine ingredients, then bake" → and what are "ingredients"? That's another list. Each step can refer to another step, and your recursive parser works the same way.

## Understanding Your Tokens

Before we parse, let's understand what you're working with. Your token stream is:

```
Number(8) → Plus → Number(5) → Star → Number(6) → Eof
positions: (0,1)   (0,3)     (0,5)   (0,7)     (0,9)   (1,0)
```

Each token knows what it is (its `token_type`), what it looks like (`lexeme`), and where it came from (`position`).

## The Grammar Explained

Your grammar defines the rules:

```
expression → term ((Plus | Minus) term)*
term       → factor ((Star | Slash) factor)*
factor     → Number | "(" expression ")"
```

This is written in a specific way to automatically handle operator precedence. Notice how multiplication/division (`term` → `factor`) is nested deeper than addition/subtraction (`expression` → `term`). This nesting creates the precedence!

**Why is this structure important?** In mathematics, `8 + 5 * 6` means "add 8 to the product of 5 and 6" (which is 38), not "multiply the sum of 8 and 5 by 6" (which is 78). The grammar enforces this by making multiplication "closer to" the numbers, so it gets evaluated first.

## Step-by-Step: What Happens When You Parse

Let's trace through parsing `8 + 5 * 6` token by token:

### Step 1: You Call `parse_expression()`

The parser function starts. It doesn't know what's coming, but it says "an expression starts with a term, so let me call parse_term()".

### Step 2: You Call `parse_term()` (from inside expression)

Now you're parsing a term. You say "a term starts with a factor, so let me call parse_factor()".

### Step 3: You Call `parse_factor()` (from inside term)

Now you're at the bottom level. You look at the current token—it's `Number(8)`. You can handle this! You consume it and return a `Literal(8)` node. You're done with this function call.

### Step 4: Back in `parse_term()`

You have a factor now. You ask: "is there a multiplication operator next?" You look at the next token—it's `Plus`. No, that's not multiplication. So you return the factor `Literal(8)` back to `parse_expression()`.

### Step 5: Back in `parse_expression()`

You have a term. You ask: "is there an addition operator next?" You look—it's `Plus`. Yes! So you:
- Save the operator `Plus`
- Consume it
- Call `parse_term()` again to get the right side

### Step 6: You Call `parse_term()` Again

Same as before: you call `parse_factor()` to get `Number(5)`.

Back in `parse_term()`, you ask: "is there a multiplication operator next?" You look—it's `Star`. Yes! So you:
- Save the operator `Star`
- Consume it
- Call `parse_factor()` again to get `Number(6)`
- Now you ask again: "is there another multiplication operator?" You see `Eof`, so no. You're done with this `parse_term()` call.
- You return `Binary { left: Literal(5), operator: Star, right: Literal(6) }`

### Step 7: Back in `parse_expression()` (Still!)

You have the right side: `Binary { left: Literal(5), operator: Star, right: Literal(6) }` which represents `5 * 6`.

You combine it with what you had on the left:
```
Binary {
  left: Literal(8),
  operator: Plus,
  right: Binary { left: Literal(5), operator: Star, right: Literal(6) }
}
```

This represents `8 + (5 * 6)`. Done!

## The Code Structure

Here's the pattern you need to understand:

```rust
fn parse_expression() -> Expr {
    // An expression is: term + term - term + term...
    let mut left = parse_term();  // Get the first term
    
    while current_token_is(Plus) || current_token_is(Minus) {
        let operator = current_token().clone();
        consume_current_token();  // Move to next token
        let right = parse_term();  // Get next term
        left = Expr::Binary { left: Box::new(left), operator, right: Box::new(right) };
    }
    
    return left;
}

fn parse_term() -> Expr {
    // A term is: factor * factor / factor * factor...
    let mut left = parse_factor();  // Get the first factor
    
    while current_token_is(Star) || current_token_is(Slash) {
        let operator = current_token().clone();
        consume_current_token();  // Move to next token
        let right = parse_factor();  // Get next factor
        left = Expr::Binary { left: Box::new(left), operator, right: Box::new(right) };
    }
    
    return left;
}

fn parse_factor() -> Expr {
    let token = current_token().clone();
    
    if token_type_is_number(token) {
        consume_current_token();
        return Expr::Literal(token);
    }
    
    if token_type_is_lparen(token) {
        consume_current_token();  // Consume "("
        let expr = parse_expression();  // Recursively parse what's inside
        consume_current_token();  // Consume ")"
        return Expr::Grouping(Box::new(expr));
    }
    
    // If we get here, error!
    panic!("Unexpected token");
}
```

## Why the Structure Works: Precedence

The key insight is this: **lower precedence operators are parsed at higher levels of the function call stack**.

When you're in `parse_expression()`, you're looking for `+` and `-`. When you're in `parse_term()`, you're looking for `*` and `/`. This means:

- When parsing `8 + 5 * 6`, you first get `8` as a term
- Then you see `+`, so you parse the right side
- To parse the right side, you call `parse_term()`, which handles `5 * 6` as a single unit
- So `5 * 6` gets grouped together before being added to `8`

**This automatic nesting is what makes operator precedence work!** You don't need special rules; the grammar structure does it for you.

## Understanding Box and Ownership

You're using `Box<Expr>` because:

1. **Recursion needs bounded size**: An `Expr` can contain other `Expr` values. Without `Box`, Rust wouldn't know how big an `Expr` is (it could be infinitely nested). `Box` gives Rust a fixed size to work with.

2. **Ownership and references**: `Box` lets you own the inner expression while also storing a reference-like pointer to it.

Just think of `Box<Expr>` as "I own an expression that's stored elsewhere". When you see `Box::new(left)`, you're saying "take ownership of this expression and wrap it in a box".

## Complete, Runnable Example

Here's a full working parser:

```rust
use scanner::token::Token;

#[derive(Debug, Clone)]
pub enum Expr {
    Literal(Token),
    Binary {
        left: Box<Expr>,
        operator: Token,
        right: Box<Expr>,
    },
    Grouping(Box<Expr>),
}

pub struct Parser {
    tokens: Vec<Token>,
    current: usize,  // Which token are we looking at?
}

impl Parser {
    pub fn new(tokens: Vec<Token>) -> Self {
        Parser { tokens, current: 0 }
    }

    // Helper: peek at the current token without consuming it
    fn peek(&self) -> &Token {
        &self.tokens[self.current]
    }

    // Helper: move to the next token
    fn advance(&mut self) -> &Token {
        let token = &self.tokens[self.current];
        self.current += 1;
        token
    }

    // Helper: check if current token matches a type
    fn check(&self, token_type: TokenType) -> bool {
        if self.is_at_end() {
            return false;
        }
        self.peek().token_type == token_type
    }

    // Helper: check if we've run out of tokens
    fn is_at_end(&self) -> bool {
        self.peek().token_type == TokenType::Eof
    }

    // The main entry point
    pub fn parse(&mut self) -> Expr {
        self.parse_expression()
    }

    // Level 1: Handle addition and subtraction (lowest precedence)
    fn parse_expression(&mut self) -> Expr {
        let mut left = self.parse_term();

        while self.check(TokenType::Plus) || self.check(TokenType::Minus) {
            let operator = self.peek().clone();
            self.advance();
            let right = self.parse_term();
            left = Expr::Binary {
                left: Box::new(left),
                operator,
                right: Box::new(right),
            };
        }

        left
    }

    // Level 2: Handle multiplication and division (higher precedence)
    fn parse_term(&mut self) -> Expr {
        let mut left = self.parse_factor();

        while self.check(TokenType::Star) || self.check(TokenType::Slash) {
            let operator = self.peek().clone();
            self.advance();
            let right = self.parse_factor();
            left = Expr::Binary {
                left: Box::new(left),
                operator,
                right: Box::new(right),
            };
        }

        left
    }

    // Level 3: Handle numbers and grouping (highest precedence)
    fn parse_factor(&mut self) -> Expr {
        if self.check(TokenType::Number) {
            let token = self.peek().clone();
            self.advance();
            return Expr::Literal(token);
        }

        if self.check(TokenType::LeftParen) {
            self.advance();  // consume "("
            let expr = self.parse_expression();  // Parse what's inside
            self.advance();  // consume ")"
            return Expr::Grouping(Box::new(expr));
        }

        panic!("Expected number or '(', got {:?}", self.peek());
    }
}
```

## Testing It Out

Given your tokens `[8, +, 5, *, 6]`, parsing would produce:

```
Binary {
    left: Literal(Token { type: Number, lexeme: "8" }),
    operator: Token { type: Plus },
    right: Binary {
        left: Literal(Token { type: Number, lexeme: "5" }),
        operator: Token { type: Star },
        right: Literal(Token { type: Number, lexeme: "6" })
    }
}
```

Which represents: `8 + (5 * 6)`. Perfect!

## Key Takeaways

The core concepts are:

**Recursive Descent**: Each grammar rule becomes a function. That function handles one level of the grammar by calling other functions for nested rules.

**Precedence Through Structure**: Higher precedence operators are parsed deeper in the function call stack, naturally grouping them tighter.

**Left-to-Right Processing**: You maintain a `current` pointer and move through tokens sequentially.

**Building Up**: You build from the bottom (factors) up to the top (expressions), constructing the tree as you go.

Once you internalize this pattern, you'll find that parsers become much easier to understand and write!
